/* * @Title	DotFont Class * @exp		This Class make chara by Some MoveClips.  * 			任意のテキストをドット文字(ドット=MovieClip)で再現する * * @author	TAKEISHI Shun-ichi (T-kis.net) * @version	0.8 * * @history * 0.80　08.10.04　β Version Release  * Next Step in near the feature.Licensed under the MIT LicenseCopyright (c) 2008 TAKEISHI Syun-ichi And the Spark project.   */package dot{	import flash.display.*;	import flash.events.*;	import flash.geom.*;	import flash.text.*;//	import fl.transitions.*;//	import fl.transitions.easing.*;	public class DotFont extends MovieClip {		/*処理用変数*/		private var text_mc:MovieClip = new MovieClip();		private var text_tf:TextField = new TextField();		private var text_style:TextFormat;		private var text_bm:Bitmap;		private var text_bmd:BitmapData;		private var bmdMa:Matrix;//テキストをビットマップ化するときのマトリックス		private var bmdCt:ColorTransform;//テキストをビットマップ化するときのカラー		private var bmdRec:Rectangle;//テキストをビットマップ化するサイズ		private var w:int;//対象とする横幅		private var h:int;//対象とする縦幅		private var fontsize:int; //フォントサイズ				/*プロパティ*/		public var ndot:Number;//文字の精細さ(縦の幅をいくつに分けるか)		public var dotper:Number;//文字の精細さ(縦の幅をいくつに分けるか)		public var text_mc_ary:Array = new Array();//ターゲットとするMCを配置する座標の多次元配列[x座標,y座標]				public var mcsize:Number; //MCサイズの変更			/*コンストラクタ*/		public function DotFont(words:String,fonttype:String,_fontsize:int,_dot:int=0,_dotper:Number=0.7,_mcsize:Number=1):void {			//変数の引き継ぎ			fontsize = _fontsize;			if(_dot==0){				ndot = Math.round(fontsize/4);			}else{				ndot = _dot;			}			mcsize = _mcsize;			dotper = _dotper;						//テキスト元データを作成			text_style = new TextFormat(fonttype,fontsize);			text_tf.text = words;			text_tf.setTextFormat(text_style);			text_mc.addChild(text_tf);			text_tf.width = fontsize * (words.length+1);			text_tf.height = fontsize * 1.2;			w = text_mc.width;			h = text_mc.height;			//Bitmap化定義			bmdMa = new Matrix();			bmdCt = new ColorTransform();			bmdRec = new Rectangle(0,0,w,h);			//MCnoBitMap化			text_bmd = new BitmapData(w,h,true,0xffffffff);			text_bm = new Bitmap(text_bmd);			//bmエリアに描画			text_bmd.draw(text_mc,bmdMa,bmdCt,"normal",bmdRec);			//座標を配列に挿入する			bitmapspoit();			//ビットマープデータを破棄			text_bmd.dispose();		}		/* bitmapspoit関数		ビットマップデータを正方形のマス毎に分割し、ブラックのマスだけ判定する		別クラス(bitmapspoit)から、リターンされる配列を受け取る		*/		private function bitmapspoit():void {			var dotsize:int = Math.floor(fontsize/ndot);//一つのマス目の大きさ(端数切り捨て)			var dotnumber_x:int;			var dotnumber_x_max:int = Math.round(w/dotsize);//何マスに分割するか（x軸）→MCを配置する数。			var dotnumber_y:int;			var dotnumber_y_max:int = Math.round(h/dotsize);//何マスに分割するか（y軸）→MCを配置する数。			var dotblack:int;//そのマスがどれだけ黒いか			var dotcount:int;//マスの中で何番目のマスか？			var dotcolor:Number;//マスの黒さパーセンテージ			for (dotnumber_y=0; dotnumber_y<dotnumber_y_max; dotnumber_y++) {				for (dotnumber_x=0; dotnumber_x < dotnumber_x_max; dotnumber_x++) {					/*ここからマスの中の色を確認*/					//マスの中の色を取るための初期化処理					var dot_x:int = dotnumber_x*dotsize;//マスの基準となる座標(x軸）→MCの配置の座標					var dot_y:int = dotnumber_y*dotsize;//マスの基準となる座標(y軸）→MCの配置座標					dotcount =1;					dotblack=0;					//ブラックのマスがどれだけあるかを判定(ブラックだったらdotblackに加算）					for (var yi:int=dot_y; yi < (dotnumber_y+1)*dotsize; yi++) {						for (var xi:int=dot_x; xi < (dotnumber_x+1)*dotsize; xi++) {							if (text_bmd.getPixel(xi,yi)==0x000000) {								dotblack++;							}						}						dotcount++;					}					//マス全体のうち何割以上が黒ければMCを必要とする座標と判定し、配列へ座標を投げる					dotcolor= dotblack/dotcount;//黒さ比率を計算					if (dotcolor>dotper) {						text_mc_ary.push([dot_x,dot_y]);					}				}			}		}		//配列に沿って、MCオブジェクト(リンケージ名:DotFont_mc)を配置する		private var _mcObj:Object = new Object();		public function addChildChara(mcClass:Class):void {			var dotnum:uint = text_mc_ary.length;			for (var i:int=1; i < dotnum; i++) {				_mcObj[i] = new mcClass();				_mcObj[i].width = _mcObj[i].width* mcsize;				_mcObj[i].height = _mcObj[i].height * mcsize;				_mcObj[i].x = text_mc_ary[i][0];				_mcObj[i].y = text_mc_ary[i][1];				addChild(_mcObj[i]);			}		}		//配列に沿って、MCオブジェクトを撤去するオブジェクト		public function removeChildChara():void {			var dotnum:uint = text_mc_ary.length;			for (var i:int=1; i < text_mc_ary.length; i++) {				removeChild(_mcObj[i]);			}		}	}}